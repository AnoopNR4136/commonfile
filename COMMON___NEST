////////////////////////////////New Pjct
in cmd prompt
npm i -g @nestjs/cli
nest update


nest new pjct_name

/////////////////TypeOrm
npm i --save @nestjs/typeorm typeorm pg




//////////////////////////////////////////////////////////////config
 1>  //Installing config npm
 
   npm i --save @nestjs/config    
 2>  //enabling/registering config
 
 ConfigModule.forRoot({
      isGlobal: true,   //can be used in any modules
    }),
    
       OR
     ConfigModule.forRoot(), //Can be use only in root module (ie app module)
     //Note : By registering env it look for the .env file in ROOT DIRECTORY.
     //OBJECT PASS to forRoot
     //1> isGlobal :true => can be used in any modules
     //2> envFilePath: '.development.env',  envFilePath: ['.env.development.local', '.env.development'], => other than default Path (ie ROOT DIRECTORY)
     
     
     ////procces.env doesnt work in outside of any module (files other than controller,service ,repository in the module) so we use dependency injection .
     //constructor(private configService: ConfigService) {}
     //  type: this.configService.get('HOST'),  
     
  3> geting values 
  
   console.log(process.env);
   console.log(process.env.HOST);
 --------------------------
 
 
 .env
 
 HOST=localhost
PORT=5432
USER_NAME=postgres
PASSWORD=postgres
DATABASE=db_auth
CONNECTION_TYPE=postgres
SYNCHRONIZE=true
 
 config.ts
 
 import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { TypeOrmModuleOptions, TypeOrmOptionsFactory } from '@nestjs/typeorm';

@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory {
  constructor(private configService: ConfigService) {}

  async createTypeOrmOptions(): Promise<TypeOrmModuleOptions> {
    const options = {
      type: this.configService.get('CONNECTION_TYPE'),  
      host: this.configService.get('HOST'),
      port: this.configService.get<number>('PORT'),
      username: this.configService.get('USER_NAME'),
      password: this.configService.get('PASSWORD'),
      database: this.configService.get('DATABASE'),
      synchronize: this.configService.get('SYNCHRONIZE'),
      autoLoadEntities: true,
      logging: true,
      entities: ['dist/**/*.entity{.ts,.js}'],
    } as TypeOrmModuleOptions;
    return options;
  }
}


app.module.ts

import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { AuthModule } from './auth/auth.module';
import { TypeOrmConfigService } from './config/config';
import { UserModule } from './user/user.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,   //enabling config
    }),
    // TypeOrmModule.forRoot(typeOrmConfig),
    TypeOrmModule.forRootAsync({
      useClass: TypeOrmConfigService,
    }),
    AuthModule,
    UserModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}









//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////Vallidation 

npm install class-validator --save
npm install class-transformer --save

app.useGlobalPipes(new ValidationPipe());

app.enableCors();



???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????UUID
npm i uuid
import { v4 as uuidv4 } from 'uuid';
const oder_id = uuidv4();


//////////////////////////////////////////////////////////////////////////////////////Config
import { TypeOrmModuleOptions } from '@nestjs/typeorm';

export const typeOrmConfig: TypeOrmModuleOptions = {
  type: 'postgres',
  host: 'localhost',
  port: 5432,
  username: 'postgres',
  password: 'postgres',
  database: 'db_ecart',
  entities: [__dirname + '/..**/*.entity.ts'],
  synchronize: true,
  autoLoadEntities: true,
  logging: true,
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////Swagger

 npm install --save @nestjs/swagger swagger-ui-express


app.useGlobalPipes(new ValidationPipe());
  const config = new DocumentBuilder()
    .setTitle('Eastern-Market-Portal')
    .setDescription('')
    .setVersion('1.0')
    .addTag('')
    .addBearerAuth()
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);


nsest cli jsoon

"compilerOptions": {
    "deleteOutDir": true,
    "plugins":["@nestjs/swagger/plugin"]
  }










/////////////////ALreday Exist

???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

catch (err) {
            console.log(err)
            if (err.code === "23505") {
                throw new ConflictException('Category is already Exist !!!')
            }
            else {

                throw new InternalServerErrorException();
            }

            console.log(err)



/////////////////HashPassword


npm i bcrypt

import * as bcrypt from 'bcrypt';

const salt = await bcrypt.genSalt();

async hashPassword(password:string,salt:string) :Promise<string>{
        const hash = await bcrypt.hash(password,salt)
        console.log("Hash "+hash);
        return hash
    }


???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
?????????????????????????JWT STRATEGY

npm install --save @nestjs/jwt passport-jwt
npm i --save @nestjs/passport passport

npm i --save @nestjs/jwt @nestjs/passport

1> in authmodule.ts

 import { PassportModule } from '@nestjs/passport';
 import { JwtModule, JwtService } from '@nestjs/jwt';

 PassportModule.register({ defaultStrategy: 'jwt' }),
 JwtModule.register({
    secret: 'topSecret51',
    signOptions: { expiresIn: 5256000000 },
  }),
  


private jwtService: JwtService,
const token = this.jwtService.sign({
            user_name: createUserDto.user_name,
          });
          
          
PassportModule.register({ defaultStrategy: 'jwt' }),
  JwtModule.register({
    secret: 'topSecret51',
    signOptions: { expiresIn: 5256000000 },
  }),          





import { Injectable, UnauthorizedException } from "@nestjs/common";
import { PassportStrategy } from "@nestjs/passport";
import { InjectRepository } from "@nestjs/typeorm";
import { UserRepository } from "./user.repository";
import { Strategy,ExtractJwt } from 'passport-jwt'
import { User } from "./entities/user.entity";
import { JwtPayload } from "src/user/jwt-paylod.interface";

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy){
    constructor(
@InjectRepository(UserRepository)
private userRepository:UserRepository,
    ){
        super({
            jwtFromRequest :ExtractJwt.fromAuthHeaderAsBearerToken(),
            secretOrKey:'topSecret51' ,  
        });
    }

    async validate(payload :JwtPayload) :Promise<User>{
        
        const { name } = payload;

        console.log("Name "+name);

        const findUser = await this.userRepository.findOne({name})
        // console.log(findUser.name);

        console.log("Atuthvalidation "+findUser)

        if(!findUser){
            throw new UnauthorizedException()
        }
        return findUser;
    }
}


  providers: [AuthService,JwtStrategy],
  exports:[JwtStrategy,PassportModule]
  
  @ApiBearerAuth()

in each module

  imports: [PassportModule.register({ defaultStrategy: 'jwt' })],

???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????GET USER DECORATOR
import { createParamDecorator, ExecutionContext } from "@nestjs/common";
import { User } from "src/user/entities/user.entity";


 export  const GetUser = createParamDecorator((data, ctx: ExecutionContext): User => {
    const req =  ctx.switchToHttp().getRequest();
    return req.user;
});
get user data
@GetUser() user:User


??????????????????????????????serve static
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { NestExpressApplication } from '@nestjs/platform-express';
import * as express from 'express';
import { join } from 'path';
async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  app.use(
    '/imagecategory',
    express.static(join(__dirname, '..', 'imagecategory')),
  );
  app.use(
    '/imagesubcategory',
    express.static(join(__dirname, '..', 'imagesubcategory')),
  );
  app.use(
    '/imageproduct',
    express.static(join(__dirname, '..', 'imageproduct')),
  );
  app.enableCors();
  await app.listen(3000);
}
bootstrap();



//////////////nestjsx
npm i @nestjsx/crud class-transformer class-validator

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////Data Array


  @ValidateNested({ each: true })
  @IsArray()
  @Type(() => DataArray)
  data_list: DataArray[];






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////File Uploads

npm i -D @types/multer


@Post('upload')
 @UseInterceptors(FileInterceptor('file',
      {
        storage: diskStorage({
          destination: './avatars', 
          filename: (req, file, cb) => {
          const randomName = Array(32).fill(null).map(() => (Math.round(Math.random() * 16)).toString(16)).join('')
          return cb(null, `${randomName}${extname(file.originalname)}`)
        }
        })
      }
    )
    )
  createCategory(
    @Body(ValidationPipe) createCategoryDto: CreateCategoryDto,
    @UploadedFile() file: Express.Multer.File,
  ): Promise<Category | {}> {
    console.log(createCategoryDto);

    return this.categoryService.createCategory(createCategoryDto, file);
  }
  
  
  
  common class for delete
  
  import { extname } from 'path';

export class CommonFunction {
  //Delete File
  async deleteFile(file_path: string) {
    const fs = require('fs');
    fs.unlink(file_path, function (err) {
      if (err) {
        console.log('Error ' + err);
        throw err;
      } else {
        console.log('Successfully deleted the file.');
      }
    });
  }
}


/////////////////////////////////////////////////////////////////////////////////////////////////MailSend

https://mailtrap.io/inboxes/1450528/messages/2335198984/smtp_info

